/**
 * @module @semaphore-protocol/data
 * @version 4.0.0-beta.13
 * @file A library for querying Semaphore smart contract.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/data}
*/
import { isSupportedNetwork, getDeployedContract, defaultNetwork } from '@semaphore-protocol/utils/networks';
import { ZeroAddress } from 'ethers/constants';
import { Contract } from 'ethers/contract';
import { JsonRpcProvider, AnkrProvider, PocketProvider, EtherscanProvider, CloudflareProvider, AlchemyProvider, InfuraProvider } from 'ethers/providers';
import axios from 'axios';

/**
 * Validates the type of a given parameter against an expected type.
 * Throws a {@link TypeError} if the validation fails.
 * This function is useful for ensuring that function arguments conform to expected types at runtime.
 * @param value The value of the parameter to check.
 * @param name The name of the parameter, used in the error message for easier debugging.
 * @param type The expected JavaScript type as a string (e.g., 'string', 'number', 'object').
 * @throws {TypeError} Throws an error if the type of `value` does not match the `type`.
 */
function checkParameter(value, name, type) {
    if (typeof value !== type) {
        throw new TypeError(`Parameter '${name}' is not ${type === "object" ? "an" : "a"} ${type}`);
    }
}

/**
 * Fetches a list of blockchain events from a smart contract based on specified filters and starting block.
 * @param contract An instance of an ethers Contract connected to the blockchain.
 * @param eventName The name of the event to filter.
 * @param filterArgs Optional arguments to further filter the events.
 * @param startBlock The block number from which to start fetching events (defaults to 0).
 * @returns A promise that resolves to an array of event logs, each including event arguments and the block number.
 */
async function getEvents(contract, eventName, filterArgs = [], startBlock = 0) {
    const filter = contract.filters[eventName](...filterArgs);
    const events = (await contract.queryFilter(filter, startBlock));
    return events.map(({ args, blockNumber }) => [...args, blockNumber]);
}

var SemaphoreABI = [
	{
		inputs: [
			{
				internalType: "contract ISemaphoreVerifier",
				name: "_verifier",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
		],
		name: "LeafAlreadyExists",
		type: "error"
	},
	{
		inputs: [
		],
		name: "LeafCannotBeZero",
		type: "error"
	},
	{
		inputs: [
		],
		name: "LeafDoesNotExist",
		type: "error"
	},
	{
		inputs: [
		],
		name: "LeafGreaterThanSnarkScalarField",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__CallerIsNotTheGroupAdmin",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__GroupDoesNotExist",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__GroupHasNoMembers",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__InvalidProof",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeDepthIsNotSupported",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeRootIsExpired",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__MerkleTreeRootIsNotPartOfTheGroup",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Semaphore__YouAreUsingTheSameNullifierTwice",
		type: "error"
	},
	{
		inputs: [
		],
		name: "WrongSiblingNodes",
		type: "error"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "oldAdmin",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "GroupAdminUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "GroupCreated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "oldMerkleTreeDuration",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newMerkleTreeDuration",
				type: "uint256"
			}
		],
		name: "GroupMerkleTreeDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newIdentityCommitment",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MemberUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "startIndex",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256[]",
				name: "identityCommitments",
				type: "uint256[]"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			}
		],
		name: "MembersAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "merkleTreeDepth",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "merkleTreeRoot",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "nullifier",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "message",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "scope",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256[8]",
				name: "points",
				type: "uint256[8]"
			}
		],
		name: "ProofValidated",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			}
		],
		name: "addMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "identityCommitments",
				type: "uint256[]"
			}
		],
		name: "addMembers",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "admin",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "merkleTreeDuration",
				type: "uint256"
			}
		],
		name: "createGroup",
		outputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "admin",
				type: "address"
			}
		],
		name: "createGroup",
		outputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getGroupAdmin",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getMerkleTreeDepth",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getMerkleTreeRoot",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			}
		],
		name: "getMerkleTreeSize",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "groupCounter",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "groups",
		outputs: [
			{
				internalType: "uint256",
				name: "merkleTreeDuration",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			}
		],
		name: "hasMember",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			}
		],
		name: "indexOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "merkleProofSiblings",
				type: "uint256[]"
			}
		],
		name: "removeMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "updateGroupAdmin",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "newMerkleTreeDuration",
				type: "uint256"
			}
		],
		name: "updateGroupMerkleTreeDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "identityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "newIdentityCommitment",
				type: "uint256"
			},
			{
				internalType: "uint256[]",
				name: "merkleProofSiblings",
				type: "uint256[]"
			}
		],
		name: "updateMember",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "merkleTreeDepth",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "merkleTreeRoot",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "nullifier",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "message",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "scope",
						type: "uint256"
					},
					{
						internalType: "uint256[8]",
						name: "points",
						type: "uint256[8]"
					}
				],
				internalType: "struct ISemaphore.SemaphoreProof",
				name: "proof",
				type: "tuple"
			}
		],
		name: "validateProof",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "verifier",
		outputs: [
			{
				internalType: "contract ISemaphoreVerifier",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "groupId",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "merkleTreeDepth",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "merkleTreeRoot",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "nullifier",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "message",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "scope",
						type: "uint256"
					},
					{
						internalType: "uint256[8]",
						name: "points",
						type: "uint256[8]"
					}
				],
				internalType: "struct ISemaphore.SemaphoreProof",
				name: "proof",
				type: "tuple"
			}
		],
		name: "verifyProof",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];

/**
 * The SemaphoreEthers class provides a high-level interface to interact with the Semaphore smart contract
 * using the {@link https://docs.ethers.org/v5/ | ethers.js} library. It encapsulates all necessary functionalities to connect to Ethereum networks,
 * manage contract instances, and perform operations such as retrieving group information or checking group memberships.
 * This class simplifies the interaction with the Ethereum blockchain by abstracting the details of network connections
 * and contract interactions.
 */
class SemaphoreEthers {
    /**
     * Constructs a new SemaphoreEthers instance, initializing it with a network or a custom Ethereum node URL,
     * and optional configuration settings for the ethers provider and contract.
     * @param networkOrEthereumURL The Ethereum network name or a custom JSON-RPC URL to connect to.
     * @param options Configuration options for the ethers provider and the Semaphore contract.
     */
    constructor(networkOrEthereumURL = defaultNetwork, options = {}) {
        checkParameter(networkOrEthereumURL, "networkOrSubgraphURL", "string");
        if (options.provider) {
            checkParameter(options.provider, "provider", "string");
        }
        else if (!networkOrEthereumURL.startsWith("http")) {
            options.provider = "infura";
        }
        if (options.apiKey) {
            checkParameter(options.apiKey, "apiKey", "string");
        }
        if (isSupportedNetwork(networkOrEthereumURL)) {
            const { address, startBlock } = getDeployedContract(networkOrEthereumURL);
            options.address ?? (options.address = address);
            options.startBlock ?? (options.startBlock = startBlock);
        }
        else {
            if (options.address === undefined) {
                throw new Error(`Network '${networkOrEthereumURL}' needs a Semaphore contract address`);
            }
            options.startBlock ?? (options.startBlock = 0);
        }
        let provider;
        switch (options.provider) {
            case "infura":
                provider = new InfuraProvider(networkOrEthereumURL, options.projectId, options.projectSecret);
                break;
            case "alchemy":
                provider = new AlchemyProvider(networkOrEthereumURL, options.apiKey);
                break;
            case "cloudflare":
                provider = new CloudflareProvider(networkOrEthereumURL);
                break;
            case "etherscan":
                provider = new EtherscanProvider(networkOrEthereumURL, options.apiKey);
                break;
            case "pocket":
                provider = new PocketProvider(networkOrEthereumURL, options.applicationId, options.applicationSecret);
                break;
            case "ankr":
                provider = new AnkrProvider(networkOrEthereumURL, options.apiKey);
                break;
            default:
                if (!networkOrEthereumURL.startsWith("http")) {
                    throw new Error(`Provider '${options.provider}' is not supported`);
                }
                provider = new JsonRpcProvider(networkOrEthereumURL);
        }
        this._network = networkOrEthereumURL;
        this._options = options;
        this._contract = new Contract(options.address, SemaphoreABI, provider);
    }
    /**
     * Retrieves the Ethereum network or custom URL currently used by this instance.
     * @returns The network or URL as a string.
     */
    get network() {
        return this._network;
    }
    /**
     * Retrieves the options used for configuring the ethers provider and the Semaphore contract.
     * @returns The configuration options.
     */
    get options() {
        return this._options;
    }
    /**
     * Retrieves the ethers Contract instance used to interact with the Semaphore contract.
     * @returns The Contract instance.
     */
    get contract() {
        return this._contract;
    }
    /**
     * Fetches the list of group IDs from the Semaphore contract by querying the "GroupCreated" events.
     * @returns A promise that resolves to an array of group IDs as strings.
     */
    async getGroupIds() {
        const groups = await getEvents(this._contract, "GroupCreated", [], this._options.startBlock);
        return groups.map((event) => event[0].toString());
    }
    /**
     * Retrieves detailed information about a specific group by its ID. This method queries the Semaphore contract
     * to get the group's admin, Merkle tree root, depth, and size.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to a GroupResponse object.
     */
    async getGroup(groupId) {
        checkParameter(groupId, "groupId", "string");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const merkleTreeRoot = await this._contract.getMerkleTreeRoot(groupId);
        const merkleTreeDepth = await this._contract.getMerkleTreeDepth(groupId);
        const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
        const group = {
            id: groupId,
            admin: groupAdmin,
            merkleTree: {
                depth: Number(merkleTreeDepth),
                size: Number(merkleTreeSize),
                root: merkleTreeRoot.toString()
            }
        };
        return group;
    }
    /**
     * Fetches a list of members from a specific group. This method queries the Semaphore contract for events
     * related to member additions and updates, and constructs the list of current group members.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of member identity commitments as strings.
     */
    async getGroupMembers(groupId) {
        checkParameter(groupId, "groupId", "string");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const memberRemovedEvents = await getEvents(this._contract, "MemberRemoved", [groupId], this._options.startBlock);
        const memberUpdatedEvents = await getEvents(this._contract, "MemberUpdated", [groupId], this._options.startBlock);
        const memberUpdatedEventsMap = new Map();
        for (const [, index, , newIdentityCommitment, , blockNumber] of memberUpdatedEvents) {
            memberUpdatedEventsMap.set(index.toString(), [blockNumber, newIdentityCommitment.toString()]);
        }
        for (const [, index, , , blockNumber] of memberRemovedEvents) {
            const groupUpdate = memberUpdatedEventsMap.get(index.toString());
            if (!groupUpdate || (groupUpdate && groupUpdate[0] < blockNumber)) {
                memberUpdatedEventsMap.set(index.toString(), [blockNumber, "0"]);
            }
        }
        const membersAddedEvents = await getEvents(this._contract, "MembersAdded", [groupId], this._options.startBlock);
        const membersAddedEventsMap = new Map();
        for (const [, startIndex, identityCommitments] of membersAddedEvents) {
            membersAddedEventsMap.set(startIndex.toString(), identityCommitments.map((i) => i.toString()));
        }
        const memberAddedEvents = await getEvents(this._contract, "MemberAdded", [groupId], this._options.startBlock);
        const members = [];
        const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
        let i = 0;
        while (i < Number(merkleTreeSize)) {
            const identityCommitments = membersAddedEventsMap.get(i.toString());
            if (identityCommitments) {
                members.push(...identityCommitments);
                i += identityCommitments.length;
            }
            else {
                members.push(memberAddedEvents[i][2]);
                i += 1;
            }
        }
        for (let j = 0; j < members.length; j += 1) {
            const groupUpdate = memberUpdatedEventsMap.get(j.toString());
            if (groupUpdate) {
                members[j] = groupUpdate[1].toString();
            }
        }
        return members;
    }
    /**
     * Retrieves a list of validated proofs for a specific group. This method queries the Semaphore contract
     * for "ProofValidated" events and returns details about each proof.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of validated proofs.
     */
    async getGroupValidatedProofs(groupId) {
        checkParameter(groupId, "groupId", "string");
        const groupAdmin = await this._contract.getGroupAdmin(groupId);
        if (groupAdmin === ZeroAddress) {
            throw new Error(`Group '${groupId}' not found`);
        }
        const proofValidatedEvents = await getEvents(this._contract, "ProofValidated", [groupId], this._options.startBlock);
        return proofValidatedEvents.map((event) => ({
            merkleTreeDepth: Number(event[1]),
            merkleTreeRoot: event[2].toString(),
            nullifier: event[3].toString(),
            message: event[4].toString(),
            scope: event[5].toString(),
            points: event[6].map((p) => p.toString())
        }));
    }
    /**
     * Checks whether a specific member is part of a group. This method queries the Semaphore contract
     * to determine if the provided identity commitment is a member of the specified group.
     * @param groupId The unique identifier of the group.
     * @param member The identity commitment of the member to check.
     * @returns A promise that resolves to true if the member is part of the group, otherwise false.
     */
    async isGroupMember(groupId, member) {
        checkParameter(groupId, "groupId", "string");
        checkParameter(member, "member", "string");
        return this._contract.hasMember(groupId, member);
    }
}

/**
 * Returns the subgraph URL related to the network passed as a parameter.
 * This function retrieves the URL of the Semaphore subgraph based on the provided network.
 * @param supportedNetwork Semaphore supported network.
 * @returns Subgraph URL.
 */
function getURL(supportedNetwork) {
    if (!isSupportedNetwork(supportedNetwork)) {
        throw new TypeError(`Network '${supportedNetwork}' is not supported`);
    }
    return `https://api.studio.thegraph.com/query/14377/semaphore-${supportedNetwork}/v4.0.0-beta`;
}

/**
 * Sends an HTTP request to a specified URL and returns the parsed response data.
 * @param url The URL to which the HTTP request is sent.
 * @param config Optional Axios request configuration to customize headers, method, timeout, etc.
 * @returns A promise that resolves to the data extracted from the response, typically in JSON format.
 */
/* istanbul ignore next */
async function request(url, config) {
    const { data } = await axios(url, {
        headers: {
            "Content-Type": "application/json",
            ...config?.headers
        },
        ...config
    });
    return data?.data;
}

/**
 * Converts a JavaScript Date object into a Unix timestamp.
 * @param date The Date object to convert.
 * @returns The Unix timestamp equivalent of the provided Date object.
 */
// eslint-disable-next-line import/prefer-default-export
function jsDateToGraphqlDate(date) {
    return Math.round(date.getTime() / 1000);
}

/**
 * The SemaphoreSubgraph class provides an interface to interact with the Semaphore smart contract
 * via subgraph queries. It enables operations such as retrieving lists of group members and validated proofs,
 * as well as checking membership within groups.
 * Each group in Semaphore is represented as a {@link https://zkkit.pse.dev/classes/_zk_kit_imt.LeanIMT.html | LeanIMT}
 * (Lean Incremental Merkle Tree). This class supports interaction through either a
 * {@link SupportedNetwork} or a direct URL to the subgraph. The subgraphs themselves are hosted on
 * {@link https://thegraph.com/ | The Graph} protocol, facilitating efficient and decentralized query processing.
 */
class SemaphoreSubgraph {
    /**
     * Initializes the SemaphoreSubgraph instance with a supported network or a custom subgraph URL.
     * This allows to interact with the Semaphore smart contract through the specified endpoint.
     * @param networkOrSubgraphURL Either a supported network identifier or a direct URL to the subgraph.
     */
    constructor(networkOrSubgraphURL = defaultNetwork) {
        checkParameter(networkOrSubgraphURL, "networkOrSubgraphURL", "string");
        if (typeof networkOrSubgraphURL === "string" && networkOrSubgraphURL.startsWith("http")) {
            this._url = networkOrSubgraphURL;
            return;
        }
        this._url = getURL(networkOrSubgraphURL);
    }
    /**
     * Retrieves the URL of the subgraph currently being used by the instance.
     * This URL points to the specific subgraph where Semaphore data is stored.
     * @returns The URL of the subgraph.
     */
    get url() {
        return this._url;
    }
    /**
     * Fetches a list of all group IDs from the subgraph. This method queries the subgraph to retrieve
     * identifiers for all groups managed by the Semaphore smart contract.
     * @returns A promise that resolves to an array of group IDs.
     */
    async getGroupIds() {
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups {
                        id
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        return groups.map((group) => group.id);
    }
    /**
     * Retrieves detailed information about groups from the subgraph based on the provided options.
     * This method can filter groups by various parameters and include additional details like members
     * and validated proofs if specified in the options.
     * @param options Configuration options to filter groups and specify which additional details to fetch.
     * @returns A promise that resolves to an array of group details.
     */
    async getGroups(options = {}) {
        checkParameter(options, "options", "object");
        const { members = false, validatedProofs = false } = options;
        checkParameter(members, "members", "boolean");
        checkParameter(validatedProofs, "validatedProofs", "boolean");
        let filtersQuery = "";
        if (options.filters) {
            const { admin, identityCommitment, timestamp, timestampGte, timestampLte } = options.filters;
            const filterFragments = [];
            if (admin) {
                filterFragments.push(`admin: "${admin}"`);
            }
            if (identityCommitment) {
                filterFragments.push(`members_: { identityCommitment: "${identityCommitment}" }`);
            }
            /* istanbul ignore next */
            if (timestamp) {
                filterFragments.push(`timestamp: "${jsDateToGraphqlDate(timestamp)}"`);
            }
            else if (timestampGte) {
                filterFragments.push(`timestamp_gte: "${jsDateToGraphqlDate(timestampGte)}"`);
            }
            else if (timestampLte) {
                filterFragments.push(`timestamp_lte: "${jsDateToGraphqlDate(timestampLte)}"`);
            }
            if (filterFragments.length > 0) {
                filtersQuery = `(where: {${filterFragments.join(", ")}})`;
            }
        }
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups ${filtersQuery} {
                        id
                        merkleTree {
                            root
                            depth
                            size
                        }
                        admin
                        ${members === true
                    ? `members(orderBy: index) {
                            identityCommitment
                        }`
                    : ""}
                        ${validatedProofs === true
                    ? `validatedProofs(orderBy: timestamp) {
                            message
                            merkleTreeRoot
                            merkleTreeDepth
                            scope
                            nullifier
                            points
                            timestamp
                        }`
                    : ""}
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        if (groups && members) {
            for (const group of groups) {
                group.members = group.members.map((member) => member.identityCommitment);
            }
        }
        return groups;
    }
    /**
     * Fetches detailed information about a specific group by its ID. This method can also retrieve
     * members and validated proofs for the group if requested via options.
     * @param groupId The unique identifier of the group.
     * @param options Configuration options to specify which details to fetch about the group.
     * @returns A promise that resolves to the details of the specified group.
     */
    async getGroup(groupId, options = {}) {
        checkParameter(groupId, "groupId", "string");
        checkParameter(options, "options", "object");
        const { members = false, validatedProofs = false } = options;
        checkParameter(members, "members", "boolean");
        checkParameter(validatedProofs, "validatedProofs", "boolean");
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups(where: { id: "${groupId}" }) {
                        id
                        merkleTree {
                            root
                            depth
                            size
                        }
                        admin
                        ${members === true
                    ? `members(orderBy: index) {
                            identityCommitment
                        }`
                    : ""}
                        ${validatedProofs === true
                    ? `validatedProofs(orderBy: timestamp) {
                            message
                            merkleTreeRoot
                            merkleTreeDepth
                            scope
                            nullifier
                            points
                            timestamp
                        }`
                    : ""}
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        if (groups && members) {
            groups[0].members = groups[0].members.map((member) => member.identityCommitment);
        }
        return groups[0];
    }
    /**
     * Retrieves a list of members from a specific group.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of group members' identity commitments.
     */
    async getGroupMembers(groupId) {
        const group = await this.getGroup(groupId, { members: true }); // parameters are checked inside getGroup
        return group.members;
    }
    /**
     * Fetches a list of validated proofs for a specific group.
     * @param groupId The unique identifier of the group.
     * @returns A promise that resolves to an array of validated proofs.
     */
    async getGroupValidatedProofs(groupId) {
        const group = await this.getGroup(groupId, { validatedProofs: true }); // parameters are checked inside getGroup
        return group.validatedProofs;
    }
    /**
     * Determines whether a specific member is part of a group. This method queries the subgraph to check
     * if the provided member's identity commitment exists within the specified group.
     * @param groupId The unique identifier of the group.
     * @param member The identity commitment of the member to check.
     * @returns A promise that resolves to true if the member is part of the group, otherwise false.
     */
    async isGroupMember(groupId, member) {
        checkParameter(groupId, "groupId", "string");
        checkParameter(member, "member", "string");
        const config = {
            method: "post",
            data: JSON.stringify({
                query: `{
                    groups(where: { id: "${groupId}", members_: { identityCommitment: "${member}" } }) {
                        id
                    }
                }`
            })
        };
        const { groups } = await request(this._url, config);
        return groups.length !== 0;
    }
}

export { SemaphoreEthers, SemaphoreSubgraph };
